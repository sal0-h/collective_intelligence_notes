A \textbf{Cellular Automaton} is a multi-dimensional discrete-time dynamical
system that is defined by
the principle of locality. properties:

\begin{tightitemize}
  \item \textbf{System state:} $n$-dimensional $\xx(t) = (x_1(t), \dots, x_n(t))$
  \item \textbf{Time:} Discrete updates at time steps
  \item \textbf{Topology:} State components arranged according to a given topology
  \item \textbf{Neighborhood $N(x_i)$:} Set of neighbors influencing $x_i$  
        Example 1D: $N(x_i)=\{x_{i-1},x_i,x_{i+1}\}$  
        Example 2D:
        
        Von Neumann: cell + 4 neighbors (up, down, left, right)
        
        Moore: cell + 8 surrounding neighbors (3x3 box)
  \item \textbf{Local updates:} Each $x_i$ evolves according to a function of itself and neighbors:  
        $F_i: S(N(x_i)) \to S_i$, where $S_i$ is the possible states of $x_i$ and $S$ are states of neighbors
\end{tightitemize}


\section*{Lattices and Boundaries:}
\textbf{Infinite/adaptive lattice}: The grid grows as the pattern propagates

\textbf{Finite lattice}
\begin{tightitemize}
    \item Hard boundary: fixed, edge cells have a fixed state
    \item Hard boundary: reflective, leftmost (rightmost) cell only diffuse right (left)
    \item Soft boundary: periodic boundary conditions, edges wrap around
\end{tightitemize}

\section*{Updating Schedules:} Synchronous, Asynchronous

\section*{Some Math}
We assume they are homogeneous (same lattice, same N, and same rule F for all cells)
and use synchronous updating.

\textbf{Combinatorics}
Let:
$k = |S|$ is the number of states per cell

$M$ is the number of cells

$r$ is the range ($floor(|N(a)|/2)$)

Then:
Number of possible state configs: $k^{M}$
,Number of possible neighborhood configurations: $k^{|N|}$
, Number of possible evolution functions (rules): $k^{\left(k^{|N|}\right)}$


\section*{Wolfram Code}

For Wolfram's 1D CA: $S = \{0, 1\}$ (so $k=2$) and the neighborhood is $r=1$ (i.e., $N(x_i) = \{x_{i-1}, x_i, x_{i+1}\}$, so $|N|=3$).

Using our formula, the number of rules = $k^{\left(k^{|N|}\right)} = 2^{\left(2^3\right)} = 2^8 = 256$.

\begin{tightitemize}
  \item \textbf{Class 1:} Evolves to a simple, stable, homogeneous state (all 0s or all 1s).  
        Information dynamics: Small changes die; information is lost.  
        Lyapunov exponent: $\lambda \le 0$
  
  \item \textbf{Class 2:} Evolves to simple periodic structures (stripes, oscillators).  
        Information dynamics: Small changes may persist locally but do not spread.  
        Lyapunov exponent: $\lambda = 0$
  
  \item \textbf{Class 3:} Evolves to chaotic, aperiodic patterns (e.g., Rule 30).  
        Information dynamics: Small changes spread out and affect distant regions.  
        Lyapunov exponent: $\lambda > 0$
  
  \item \textbf{Class 4:} Creates complex, localized, moving structures (e.g., Rule 110 is \textbf{Turing complete}).  
        Information dynamics: Small changes may or may not spread; irregular but structured dynamics.  
        Lyapunov exponent: $\lambda > 0$ (tends to 0)
\end{tightitemize}
